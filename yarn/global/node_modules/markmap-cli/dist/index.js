/*! markmap-cli v0.15.4 | MIT License */
import { readFile, writeFile } from 'fs/promises';
import { fileURLToPath } from 'url';
import { Command } from 'commander';
import open from 'open';
import updateNotifier from 'update-notifier';
import { readPackageUp } from 'read-pkg-up';
import { buildCSSItem, buildJSItem, defer } from 'markmap-common';
import { Transformer, baseJsPaths } from 'markmap-lib';
export * from 'markmap-lib';
import { join, extname } from 'path';
import { createRequire } from 'module';
import { packageDirectory } from 'pkg-dir';
import { createReadStream } from 'fs';
import { EventEmitter } from 'events';
import http from 'http';
import Koa from 'koa';
import chokidar from 'chokidar';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

const TOOLBAR_VERSION = "0.15.4";
const TOOLBAR_CSS = `markmap-toolbar@${TOOLBAR_VERSION}/dist/style.css`;
const TOOLBAR_JS = `markmap-toolbar@${TOOLBAR_VERSION}/dist/index.js`;
const renderToolbar = () => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
};
function addToolbar(transformer, assets) {
  return {
    styles: [...(assets.styles || []), ...[TOOLBAR_CSS].map(path => transformer.urlBuilder.getFullUrl(path)).map(path => buildCSSItem(path))],
    scripts: [...(assets.scripts || []), ...[TOOLBAR_JS].map(path => transformer.urlBuilder.getFullUrl(path)).map(path => buildJSItem(path)), {
      type: 'iife',
      data: {
        fn: r => {
          setTimeout(r);
        },
        getParams: () => [renderToolbar]
      }
    }]
  };
}
function removeVersionString(part) {
  return part.replace(/@.+$/, '');
}
function localProvider(path) {
  const parts = path.split('/');
  // xxx@0.0.0-alpha.0+aaaaaa
  // @scope/xxx@0.0.0-alpha.0+aaaaaa
  if (parts[0].startsWith('@')) {
    parts[1] = removeVersionString(parts[1]);
  } else {
    parts[0] = removeVersionString(parts[0]);
  }
  path = parts.join('/');
  return `/node_modules/${path}`;
}
const require = createRequire(import.meta.url);
async function doResolveFile(relpath) {
  const parts = relpath.split('/');
  const nameOffset = parts[0].startsWith('@') ? 2 : 1;
  const name = parts.slice(0, nameOffset).join('/');
  const filepath = parts.slice(nameOffset).join('/');
  const mainPath = require.resolve(name);
  const pkgDir = await packageDirectory({
    cwd: mainPath
  });
  if (!pkgDir) throw new Error(`File not found: ${relpath}`);
  const realpath = join(pkgDir, filepath);
  return realpath;
}
const cache = {};
function resolveFile(relpath) {
  cache[relpath] || (cache[relpath] = doResolveFile(relpath));
  return cache[relpath];
}

function sequence(fn) {
  let promise;
  return () => {
    promise || (promise = fn().finally(() => {
      promise = undefined;
    }));
    return promise;
  };
}
class BufferContentProvider {
  constructor() {
    this.deferredSet = new Set();
    this.events = new EventEmitter();
    this.ts = 0;
    this.content = '';
    this.line = -1;
    this.events.on('content', () => {
      this.feed({
        ts: this.ts,
        content: this.content
      });
    });
    this.events.on('cursor', () => {
      this.feed({
        line: this.line
      });
    });
  }
  async getUpdate(ts, timeout = 10000) {
    const deferred = defer();
    this.deferredSet.add(deferred);
    setTimeout(() => {
      this.feed({}, deferred);
    }, timeout);
    if (ts < this.ts) {
      this.feed({
        ts: this.ts,
        content: this.content
      }, deferred);
    }
    return deferred.promise;
  }
  feed(data, deferred) {
    if (deferred) {
      deferred.resolve(data);
      this.deferredSet.delete(deferred);
    } else {
      for (const d of this.deferredSet) {
        d.resolve(data);
      }
      this.deferredSet.clear();
    }
  }
  setCursor(line) {
    this.line = line;
    this.events.emit('cursor');
  }
  setContent(content) {
    this.ts = Date.now();
    this.content = content;
    this.events.emit('content');
  }
  dispose() {
    /* noop */
  }
}
class FileSystemProvider extends BufferContentProvider {
  constructor(fileName) {
    super();
    this.fileName = fileName;
    this.watcher = chokidar.watch(fileName).on('all', sequence(() => this.update()));
  }
  async update() {
    const content = await readFile(this.fileName, 'utf8');
    this.setContent(content);
  }
  dispose() {
    super.dispose();
    this.watcher.close();
  }
}
function startServer(paddingBottom) {
  let ts = 0;
  let root;
  let line;
  let offset = 0;
  const {
    mm,
    markmap
  } = window;
  refresh();
  function refresh() {
    fetch(`/data?ts=${ts}`).then(res => res.json()).then(res => {
      if (res.ts && res.ts > ts && res.result) {
        var _frontmatter;
        let frontmatter;
        ({
          root,
          frontmatter,
          contentLineOffset: offset
        } = res.result);
        mm.setOptions(markmap.deriveOptions((_frontmatter = frontmatter) == null ? void 0 : _frontmatter.markmap));
        mm.setData(root);
        if (!ts) mm.fit();
        ts = res.ts;
        line = -1;
      }
      if (root && res.line != null && line !== res.line) {
        line = res.line;
        const active = findActiveNode();
        if (active) mm.ensureView(active, {
          bottom: paddingBottom
        });
      }
      setTimeout(refresh, 300);
    });
  }
  function findActiveNode() {
    const lineWithoutFrontmatter = line - offset;
    let best;
    dfs(root);
    return best;
    function dfs(node) {
      var _node$payload, _node$children;
      const lines = (_node$payload = node.payload) == null ? void 0 : _node$payload.lines;
      if (lines && lines[0] <= lineWithoutFrontmatter && lineWithoutFrontmatter < lines[1]) {
        best = node;
      }
      (_node$children = node.children) == null ? void 0 : _node$children.forEach(dfs);
    }
  }
}
function setUpServer(transformer, provider, options) {
  let assets = transformer.getAssets();
  if (options.toolbar) assets = addToolbar(transformer, assets);
  const html = `${transformer.fillTemplate(null, assets)}<script>(${startServer.toString()})(${options.toolbar ? 60 : 0})</script>`;
  const app = new Koa();
  app.use(async (ctx, next) => {
    if (ctx.path === '/') {
      ctx.body = html;
    } else if (ctx.path === '/data') {
      const update = await provider.getUpdate(ctx.query.ts);
      const result = update.content == null ? null : transformer.transform(update.content || '');
      ctx.body = {
        ts: update.ts,
        result,
        line: update.line
      };
    } else {
      if (ctx.path.startsWith('/node_modules/')) {
        const relpath = ctx.path.slice(14);
        try {
          const realpath = await resolveFile(relpath);
          ctx.type = extname(relpath);
          ctx.body = createReadStream(realpath);
          return;
        } catch (err) {
          console.error(err);
        }
      }
      await next();
    }
  });
  const handle = app.callback();
  const server = http.createServer(handle);
  server.listen(() => {
    const {
      port
    } = server.address();
    console.info(`Listening at http://localhost:${port}`);
    if (options.open) open(`http://localhost:${port}`);
  });
  let closing;
  return {
    provider,
    close() {
      if (!closing) {
        closing = new Promise((resolve, reject) => server.close(err => {
          if (err) reject(err);else resolve();
        }));
      }
      return closing;
    }
  };
}
async function develop(fileName, options) {
  const transformer = new Transformer();
  transformer.urlBuilder.setProvider('local', localProvider);
  transformer.urlBuilder.provider = 'local';
  const provider = fileName ? new FileSystemProvider(fileName) : new BufferContentProvider();
  return setUpServer(transformer, provider, options);
}

async function loadFile(path) {
  if (path.startsWith('/node_modules/')) {
    const relpath = path.slice(14);
    return readFile(await resolveFile(relpath), 'utf8');
  }
  const res = await fetch(path);
  if (!res.ok) throw res;
  return res.text();
}
async function inlineAssets(assets) {
  const [scripts, styles] = await Promise.all([Promise.all((assets.scripts || []).map(async item => item.type === 'script' && item.data.src ? {
    type: 'script',
    data: {
      textContent: await loadFile(item.data.src)
    }
  } : item)), Promise.all((assets.styles || []).map(async item => item.type === 'stylesheet' ? {
    type: 'style',
    data: await loadFile(item.data.href)
  } : item))]);
  return {
    scripts,
    styles
  };
}
async function createMarkmap(options) {
  const transformer = new Transformer();
  if (options.offline) {
    transformer.urlBuilder.setProvider('local', localProvider);
    transformer.urlBuilder.provider = 'local';
  } else {
    try {
      await transformer.urlBuilder.findFastestProvider();
    } catch (_unused) {
      // ignore
    }
  }
  const {
    root,
    features,
    frontmatter
  } = transformer.transform(options.content || '');
  let assets = transformer.getUsedAssets(features);
  assets = _extends({}, assets, {
    scripts: [...baseJsPaths.map(path => transformer.urlBuilder.getFullUrl(path)).map(path => buildJSItem(path)), ...(assets.scripts || [])]
  });
  if (options.toolbar) {
    assets = addToolbar(transformer, assets);
  }
  if (options.offline) {
    assets = await inlineAssets(assets);
  }
  const html = transformer.fillTemplate(root, assets, {
    baseJs: [],
    jsonOptions: frontmatter == null ? void 0 : frontmatter.markmap
  });
  const output = options.output || 'markmap.html';
  await writeFile(output, html, 'utf8');
  if (options.open) open(output);
}
async function main() {
  var _await$readPackageUp;
  const pkg = (_await$readPackageUp = await readPackageUp({
    cwd: fileURLToPath(import.meta.url)
  })) == null ? void 0 : _await$readPackageUp.packageJson;
  if (!pkg) throw new Error('package.json not found');
  const notifier = updateNotifier({
    pkg
  });
  notifier.notify();
  const program = new Command();
  program.version(pkg.version).description('Create a markmap from a Markdown input file').arguments('<input>').option('--no-open', 'do not open the output file after generation').option('--no-toolbar', 'do not show toolbar').option('-o, --output <output>', 'specify filename of the output HTML').option('--offline', 'Inline all assets to allow the generated HTML to work offline').option('-w, --watch', 'watch the input file and update output on the fly, note that this feature is for development only').action(async (input, cmd) => {
    const content = await readFile(input, 'utf8');
    const output = cmd.output || `${input.replace(/\.\w*$/, '')}.html`;
    if (cmd.watch) {
      await develop(input, {
        open: cmd.open,
        toolbar: cmd.toolbar,
        offline: true
      });
    } else {
      await createMarkmap({
        content,
        output,
        open: cmd.open,
        toolbar: cmd.toolbar,
        offline: cmd.offline
      });
    }
  });
  program.parse(process.argv);
}

export { createMarkmap, develop, main };
